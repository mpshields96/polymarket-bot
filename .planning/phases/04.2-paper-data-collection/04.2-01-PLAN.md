---
phase: 04.2-paper-data-collection
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/execution/paper.py
  - config.yaml
  - tests/test_paper_executor.py
  - tests/test_graduation_reporter.py
  - main.py
  - docs/SETTLEMENT_MAPPING.md
autonomous: false
requirements:
  - PAPER-01
  - PAPER-02
  - PAPER-03
  - PAPER-04

must_haves:
  truths:
    - "Paper trades fill at limit + 1 tick adverse (YES fills at ask+1, NO fills at ask+1), not exact limit price"
    - "Slippage is configurable via config.yaml risk.paper_slippage_ticks and defaults to 1"
    - "Slippage does NOT apply to LiveExecutor (paper.py only)"
    - "Settlement loop result field mapping is confirmed correct against Kalshi API response structure"
    - "python main.py --graduation-status prints a formatted table of all 8 strategies' graduation progress"
    - "All 8 trading loops start and log their first heartbeat within 60 seconds"
  artifacts:
    - path: "src/execution/paper.py"
      provides: "Slippage-adjusted fill simulation"
      contains: "_apply_slippage"
    - path: "tests/test_paper_executor.py"
      provides: "Tests for slippage model and settlement result mapping"
      exports: ["TestSlippageModel", "TestSettlementResultMapping"]
    - path: "main.py"
      provides: "--graduation-status CLI flag and print_graduation_status() function"
      contains: "graduation-status"
    - path: "config.yaml"
      provides: "paper_slippage_ticks config key"
      contains: "paper_slippage_ticks"
  key_links:
    - from: "src/execution/paper.py"
      to: "config.yaml"
      via: "paper_slippage_ticks read by caller (main.py) and passed as slippage_ticks= kwarg"
      pattern: "slippage_ticks"
    - from: "main.py"
      to: "src/db.graduation_stats()"
      via: "print_graduation_status() calls db.graduation_stats() for all 8 strategies"
      pattern: "graduation_stats"
    - from: "setup/verify.py"
      to: "src/db.graduation_stats()"
      via: "check_graduation_status() — already wired, verify still passes"
      pattern: "graduation_stats"
---

<objective>
Paper data collection infrastructure: slippage model, settlement verification, and graduation reporter.

Purpose: Enable realistic paper P&L (not optimistic fills), confirm settlement result logic is correct, and give Matthew a single command to check how close each strategy is to going live.
Output: Slippage-adjusted PaperExecutor, confirmed settlement field mapping, `--graduation-status` CLI command, and a clean 8-loop startup verification.
</objective>

<execution_context>
@/Users/matthewshields/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matthewshields/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/matthewshields/Projects/polymarket-bot/.planning/ROADMAP.md
@/Users/matthewshields/Projects/polymarket-bot/.planning/STATE.md
@/Users/matthewshields/Projects/polymarket-bot/CLAUDE.md
@/Users/matthewshields/Projects/polymarket-bot/docs/GRADUATION_CRITERIA.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/execution/paper.py (current PaperExecutor — NOTE: main.py uses keyword-arg call style):
```python
class PaperExecutor:
    def __init__(self, db: DB):
        self._db = db

    @staticmethod
    def _simulate_fill_price(side: str, market: Market, orderbook: OrderBook) -> Optional[int]:
        # YES buy: returns yes_ask (100 - best_no_bid), fallback market.yes_price
        # NO buy:  returns no_ask (100 - best_yes_bid), fallback market.no_price
        ...
```

NOTE: main.py trading loops call PaperExecutor with a different signature (keyword args):
```python
paper_exec = paper_mod.PaperExecutor(db=db, strategy_name=fomc_strategy.name)
result = paper_exec.execute(
    ticker=signal.ticker,
    side=signal.side,
    price_cents=signal.price_cents,
    size_usd=size,
    reason=signal.reason,
)
```
Check all call sites before changing the signature. `grep -rn "PaperExecutor\|paper_exec" main.py src/`

From src/db.py (graduation_stats return dict):
```python
def graduation_stats(self, strategy: str) -> dict:
    # Returns:
    #   settled_count: int
    #   win_rate: float | None
    #   brier_score: float | None
    #   consecutive_losses: int
    #   first_trade_ts: float | None
    #   days_running: float
    #   total_pnl_usd: float
```

From setup/verify.py (_GRAD thresholds — import this in print_graduation_status to avoid duplication):
```python
_GRAD = {
    "btc_lag_v1":                   (30, 7,  0.25, 4),
    "eth_lag_v1":                   (30, 7,  0.25, 4),
    "btc_drift_v1":                 (30, 7,  0.25, 4),
    "eth_drift_v1":                 (30, 7,  0.25, 4),
    "orderbook_imbalance_v1":       (30, 7,  0.25, 4),
    "eth_orderbook_imbalance_v1":   (30, 7,  0.25, 4),
    "weather_forecast_v1":          (30, 14, 0.25, 4),
    "fomc_rate_v1":                 (5,  0,  0.25, 4),
}
# Format: (min_trades, min_days, max_brier, max_consecutive_losses)
```

From main.py (existing --report pattern — mirror this for --graduation-status):
```python
parser.add_argument("--report", action="store_true", help="Print today's P&L summary and exit")
# handled after DB init, before full component initialization:
if args.report:
    print_report(db)
    db.close()
    return
```

From config.yaml (risk section where paper_slippage_ticks should live):
```yaml
risk:
  starting_bankroll_usd: 50.00
  max_single_trade_usd: 5.00
  max_daily_bets_per_strategy: 5
  paper_slippage_ticks: 1    # ADD THIS: 0 = no slippage, 1 = 1-tick adverse (default)
```

From src/strategies/base.py (Signal fields):
```python
@dataclass
class Signal:
    ticker: str
    side: str        # "yes" | "no"
    edge_pct: float
    win_prob: float
    price_cents: int
    reason: str
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add slippage model to PaperExecutor</name>
  <files>src/execution/paper.py, tests/test_paper_executor.py, config.yaml</files>
  <behavior>
    - Test: YES fill with slippage_ticks=1 returns fill_price = simulate_fill_price + 1 (adverse = buyer pays more)
    - Test: NO fill with slippage_ticks=1 returns fill_price = simulate_fill_price + 1 (adverse = buyer pays more)
    - Test: slippage_ticks=0 returns fill_price = simulate_fill_price exactly (no change)
    - Test: slippage_ticks=2 returns fill_price = simulate_fill_price + 2
    - Test: slippage never pushes fill_price above 99 (clamped to 99)
    - Test: slippage_ticks defaults to 1 if not supplied to __init__
    - Test: PnL calculated from slippage-adjusted fill_price (higher cost → lower win payout)
  </behavior>
  <action>
    FIRST write tests/test_paper_executor.py with all the above test cases. Run them — they MUST fail (RED).

    THEN implement (GREEN):

    1. Add `paper_slippage_ticks: 1` to config.yaml under the `risk:` section, below `max_daily_bets_per_strategy`:
       `paper_slippage_ticks: 1      # 0 = no slippage, 1 = 1-tick adverse fill simulation (realistic paper mode)`

    2. In src/execution/paper.py, add `_apply_slippage` static method:
       ```python
       @staticmethod
       def _apply_slippage(fill_price_cents: int, ticks: int) -> int:
           """Shift fill price adversely by ticks. Buyer always pays more. Clamped to 99."""
           return min(99, fill_price_cents + ticks)
       ```

    3. Modify PaperExecutor.__init__ to accept `slippage_ticks: int = 1`:
       ```python
       def __init__(self, db: DB, strategy_name: str = "btc_lag", slippage_ticks: int = 1):
           self._db = db
           self._strategy_name = strategy_name
           self._slippage_ticks = slippage_ticks
       ```
       NOTE: main.py already passes `strategy_name=...` as a keyword arg. Preserve backward compatibility.

    4. In execute(), after `_simulate_fill_price()`, apply slippage before the guard checks:
       ```python
       fill_price_cents = self._apply_slippage(fill_price_cents, self._slippage_ticks)
       ```

    5. Update the log line to show slippage applied:
       Include `(+{self._slippage_ticks} slip)` in the BUY log message so it is visible in paper logs.

    6. In settle() docstring add: `# result and side are both lowercase: "yes" | "no". Kalshi API returns lowercase.`

    Do NOT load slippage_ticks from config inside paper.py — keep paper.py config-free. The caller (main.py)
    reads config and passes slippage_ticks= at construction time. This matches the existing pattern.

    After tests pass, update main.py: in every place that constructs `PaperExecutor(db=db, strategy_name=...)`,
    also pass `slippage_ticks=config.get("risk", {}).get("paper_slippage_ticks", 1)`.

    Run all 324 tests to confirm nothing broken.
  </action>
  <verify>
    <automated>cd /Users/matthewshields/Projects/polymarket-bot && source venv/bin/activate && python -m pytest tests/test_paper_executor.py -v</automated>
  </verify>
  <done>
    - tests/test_paper_executor.py passes all 7+ slippage test cases
    - YES/NO fills are 1 tick worse than raw orderbook price by default
    - fill_price clamped to 99 max
    - slippage_ticks=0 gives exact fill (no regression)
    - All 324 existing tests still pass: `python -m pytest tests/ -v`
  </done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Graduation progress reporter (--graduation-status CLI command)</name>
  <files>main.py, tests/test_graduation_reporter.py</files>
  <behavior>
    - Test: print_graduation_status() with empty DB prints table with 8 rows
    - Test: table header includes columns: Strategy, Trades, Days, Brier, Streak, PnL, Status
    - Test: strategy with all thresholds met shows "READY" in Status column
    - Test: strategy with insufficient trades shows "needs X more trades" text
    - Test: fomc_rate_v1 threshold shown as 5 trades (not 30)
    - Test: weather_forecast_v1 threshold shown as 14 days (not 7)
  </behavior>
  <action>
    FIRST write tests/test_graduation_reporter.py with test cases. Run them — MUST fail (RED).

    THEN implement in main.py (GREEN):

    1. Add `--graduation-status` argparse argument alongside `--report`:
       ```python
       parser.add_argument("--graduation-status", action="store_true",
                           help="Print graduation progress for all 8 strategies and exit")
       ```

    2. Add `print_graduation_status(db)` function near `print_report()` (around line 633):
       ```python
       def print_graduation_status(db):
           """Print graduation progress table for all 8 strategies."""
           from setup.verify import _GRAD  # single source of truth for thresholds
           ...
       ```

       Table format (fixed-width):
       ```
       ════════════════════════════════════════════════════════════
         GRADUATION STATUS — 2026-02-28 14:30 UTC
       ════════════════════════════════════════════════════════════
         Strategy                    Trades  Days  Brier  Streak  P&L    Status
         ─────────────────────────────────────────────────────────
         btc_lag_v1                    0/30   0.0   n/a      0   $0.00  needs 30 trades, 7 days
         eth_lag_v1                    0/30   0.0   n/a      0   $0.00  needs 30 trades, 7 days
         btc_drift_v1                  0/30   0.0   n/a      0   $0.00  needs 30 trades, 7 days
         eth_drift_v1                  0/30   0.0   n/a      0   $0.00  needs 30 trades, 7 days
         orderbook_imbalance_v1        0/30   0.0   n/a      0   $0.00  needs 30 trades, 7 days
         eth_orderbook_imbalance_v1    0/30   0.0   n/a      0   $0.00  needs 30 trades, 7 days
         weather_forecast_v1           0/30   0.0   n/a      0   $0.00  needs 30 trades, 14 days
         fomc_rate_v1                  0/5    0.0   n/a      0   $0.00  needs 5 trades
       ════════════════════════════════════════════════════════════
         0 / 8 strategies ready for live trading.
       ════════════════════════════════════════════════════════════
       ```

       Status field logic:
       - All criteria pass: "READY FOR LIVE"
       - Consecutive losses >= max_consec: "BLOCKED (N consec losses)"
       - Otherwise: list gaps (e.g. "needs 28 trades, 6.3 days, brier 0.31>=0.25")

    3. Wire the flag in main() after DB init, before full component initialization (same pattern as --report):
       ```python
       if args.graduation_status:
           print_graduation_status(db)
           db.close()
           return
       ```

    Run all tests after implementation.
  </action>
  <verify>
    <automated>cd /Users/matthewshields/Projects/polymarket-bot && source venv/bin/activate && python -m pytest tests/test_graduation_reporter.py -v && python main.py --graduation-status</automated>
  </verify>
  <done>
    - `python main.py --graduation-status` prints formatted table, exits 0, takes under 2 seconds
    - Table shows all 8 strategies with correct strategy-specific thresholds
    - fomc shows 5 trades minimum, weather shows 14 days minimum
    - Does NOT start Kalshi/Binance connections (reads DB only)
    - All 324+ tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Settlement result field verification (test fixture + doc)</name>
  <files>tests/test_paper_executor.py, src/platforms/kalshi.py, docs/SETTLEMENT_MAPPING.md</files>
  <action>
    Confirm the settlement result field mapping is correct and document it permanently.

    Context: settlement_loop in main.py does:
    ```python
    result = market.result  # "yes" | "no" — how the market settled
    # WIN if result == side
    ```
    The question: does Kalshi API return market.result as lowercase "yes"/"no"?

    Step 1: Inspect src/platforms/kalshi.py — find where `result` is parsed from the API response.
    Look for the Market dataclass or dict construction and how `result` field is assigned.

    Step 2: If result is NOT normalized to lowercase, add `.lower()` normalization in src/platforms/kalshi.py
    where Market.result is assigned: `result = data.get("result", "").lower() or None`
    This makes settlement robust to API casing changes.

    Step 3: Add TestSettlementResultMapping class to tests/test_paper_executor.py:
    ```python
    class TestSettlementResultMapping:
        def test_result_yes_side_yes_is_win(self, paper_exec_with_db):
            pnl = paper_exec_with_db.settle(trade_id=1, result="yes", fill_price_cents=44, side="yes", count=10)
            assert pnl > 0

        def test_result_no_side_yes_is_loss(self, paper_exec_with_db):
            pnl = paper_exec_with_db.settle(trade_id=2, result="no", fill_price_cents=44, side="yes", count=10)
            assert pnl < 0

        def test_result_no_side_no_is_win(self, paper_exec_with_db):
            # NO-side bet wins when market settles "no"
            pnl = paper_exec_with_db.settle(trade_id=3, result="no", fill_price_cents=55, side="no", count=10)
            assert pnl > 0

        def test_result_yes_side_no_is_loss(self, paper_exec_with_db):
            pnl = paper_exec_with_db.settle(trade_id=4, result="yes", fill_price_cents=55, side="no", count=10)
            assert pnl < 0
    ```
    Note: settle() calls self._db.settle_trade() which needs a real trade row. Either mock the DB call
    or save a trade first in the fixture. Check existing test patterns in tests/test_db.py for guidance.

    Step 4: Create docs/SETTLEMENT_MAPPING.md:
    ```markdown
    # Settlement Result Field Mapping

    ## Kalshi API -> settlement_loop -> DB

    Field: `market.result` from GET /trade-api/v2/markets/{ticker}
    Values: "yes" | "no" (lowercase, normalized in kalshi.py)

    WIN condition: `market.result == trade["side"]`

    Examples:
    - Bet YES, market settles "yes" -> WIN
    - Bet NO, market settles "no" -> WIN (NO-side bet)
    - Bet YES, market settles "no" -> LOSS
    - Bet NO, market settles "yes" -> LOSS

    ## Verified in tests

    See tests/test_paper_executor.py :: TestSettlementResultMapping

    ## PnL formula (src/execution/paper.py)

    WIN:  pnl = (100 - fill_price_cents) * count - fees
    LOSS: pnl = -fill_price_cents * count
    Fees: 0.07 * P * (1-P) per contract, wins only (Kalshi standard fee)
    ```

    Run all tests after.
  </action>
  <verify>
    <automated>cd /Users/matthewshields/Projects/polymarket-bot && source venv/bin/activate && python -m pytest tests/test_paper_executor.py::TestSettlementResultMapping -v</automated>
  </verify>
  <done>
    - TestSettlementResultMapping passes all 4 cases
    - result field normalization confirmed (or .lower() added in kalshi.py if needed)
    - docs/SETTLEMENT_MAPPING.md created at project root docs/ dir
    - All 324+ tests still pass
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Verify all tasks complete and 8 loops start cleanly</name>
  <action>Human verification of completed automated tasks — no code changes in this task.</action>
  <what-built>
    Task 1: PaperExecutor fills at limit + 1 tick adverse (configurable), config.yaml has paper_slippage_ticks: 1
    Task 2: `python main.py --graduation-status` prints 8-strategy graduation table
    Task 3: Settlement result mapping confirmed + documented in docs/SETTLEMENT_MAPPING.md
    All 3 tasks: tests written first (TDD), all existing 324 tests still pass
  </what-built>
  <how-to-verify>
    1. Run full test suite — must be 334+ tests passing (324 + ~10 new):
       ```
       source venv/bin/activate && python -m pytest tests/ -v 2>&1 | tail -20
       ```

    2. Run graduation status command:
       ```
       python main.py --graduation-status
       ```
       Expected: table with 8 strategies, all showing 0 trades, exits immediately (no Kalshi connection)

    3. Check slippage is wired in config:
       ```
       grep paper_slippage_ticks config.yaml
       ```
       Expected: `paper_slippage_ticks: 1`

    4. Start bot and watch first 60 seconds (all 8 loops must log their heartbeat):
       ```
       python main.py
       ```
       Expected sequence within 60s:
         [trading]       t=0s  -> "Evaluating N market(s)"
         [eth_trading]   t=7s  -> "Evaluating N market(s)"
         [drift]         t=15s -> "Evaluating N market(s)"
         [eth_drift]     t=22s -> "Evaluating N market(s)"
         [btc_imbalance] t=29s -> "Evaluating N market(s)"
         [eth_imbalance] t=36s -> "Evaluating N market(s)"
         [weather]       t=43s -> "No open HIGHNY markets" OR "Evaluating N market(s)"
         [fomc]          t=51s -> "timing gate" debug OR "Evaluating N market(s)"
       Ctrl+C after confirming all 8 are running cleanly.

    5. Review docs/SETTLEMENT_MAPPING.md:
       ```
       cat docs/SETTLEMENT_MAPPING.md
       ```
  </how-to-verify>
  <verify>
    <automated>cd /Users/matthewshields/Projects/polymarket-bot && source venv/bin/activate && python -m pytest tests/ --tb=short -q 2>&1 | tail -5</automated>
  </verify>
  <done>All 5 checks above pass. Matthew types "approved".</done>
  <resume-signal>Type "approved" if all 5 checks pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
- All 334+ tests pass (python -m pytest tests/ -v)
- PaperExecutor applies 1-tick adverse slippage by default
- `python main.py --graduation-status` works without starting Kalshi/Binance connections
- All 8 loops start and log heartbeats within 60 seconds
- Settlement field mapping verified and documented
- No live trading enabled (LIVE_TRADING=false confirmed)
- No files written outside /Users/matthewshields/Projects/polymarket-bot/
- No await in src/risk/ (paper.py and main.py additions are sync-safe)
</verification>

<success_criteria>
- 334+ tests passing (was 324, adding ~10 new)
- `python main.py --graduation-status` exits 0 with formatted table in under 2 seconds
- Paper fills are 1 tick more expensive than raw orderbook price (realistic simulation)
- Settlement result "yes"/"no" confirmed lowercase, documented in SETTLEMENT_MAPPING.md
- All 8 loops emit heartbeat logs within 60s of `python main.py`
- Matthew can monitor graduation progress with a single command daily
</success_criteria>

<output>
After completion, create `/Users/matthewshields/Projects/polymarket-bot/.planning/phases/04.2-paper-data-collection/04.2-01-SUMMARY.md` following the standard summary template.
</output>
